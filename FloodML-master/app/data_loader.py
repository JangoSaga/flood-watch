import pandas as pd
import csv
import os
from datetime import datetime
import numpy as np

class DataLoader:
    """Centralized data loader for all CSV files generated by enhanced forecast/plotting"""
    
    def __init__(self, base_dir):
        self.base_dir = base_dir
        # Resolve project root as the parent of the app directory
        self.project_root = os.path.abspath(os.path.join(base_dir, '..'))
        # Read data from the root-level data/ directory
        self.data_dir = os.path.join(self.project_root, 'data')
        
    def check_data_availability(self):
        """Check which CSV files are available"""
        files_to_check = {
            '7day_flood_predictions.csv': '7-day forecast predictions',
            'final_plot.csv': 'Main plotting data',
            'risk_zones.csv': 'Risk zones with alert levels',
            'daily_summary.csv': 'Daily forecast statistics',
            'city_summary.csv': 'City-wise risk analysis'
        }
        
        status = {}
        for filename, description in files_to_check.items():
            file_path = os.path.join(self.data_dir, filename)
            status[f"{filename} ({description})"] = os.path.exists(file_path)
        
        return status
    
    def load_7day_predictions(self):
        """Load 7-day flood predictions"""
        try:
            file_path = os.path.join(self.data_dir, '7day_flood_predictions.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading 7-day predictions: {e}")
            return None
    
    def load_daily_summary(self):
        """Load daily summary data"""
        try:
            file_path = os.path.join(self.data_dir, 'daily_summary.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            # Reset index to get Date as a column
            df = df.reset_index()
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading daily summary: {e}")
            return None
    
    def load_city_summary(self):
        """Load city summary data"""
        try:
            file_path = os.path.join(self.data_dir, 'city_summary.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            # Reset index to get City as a column
            df = df.reset_index()
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading city summary: {e}")
            return None
    
    def load_risk_zones(self):
        """Load risk zones data"""
        try:
            file_path = os.path.join(self.data_dir, 'risk_zones.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading risk zones: {e}")
            return None
    
    def load_plotting_data(self):
        """Load final plotting data"""
        try:
            file_path = os.path.join(self.data_dir, 'final_plot.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading plotting data: {e}")
            return None
    
    def get_city_list(self):
        """Get list of all cities from available data"""
        cities = set()
        
        # Try to get from 7-day predictions first
        predictions = self.load_7day_predictions()
        if predictions:
            cities.update([record['City'] for record in predictions])
            return sorted(list(cities))
        
        # Fallback to cities.csv
        try:
            cities_path = os.path.join(self.data_dir, 'data', 'cities.csv')
            with open(cities_path, 'r', encoding='UTF-8') as f:
                reader = csv.reader(f)
                for row in reader:
                    if len(row) >= 1:
                        cities.add(row[0])
        except FileNotFoundError:
            pass
        
        return sorted(list(cities))
    
    def get_city_coordinates(self, city_name):
        """Get coordinates for a specific city"""
        # Try from cities.csv first
        try:
            cities_path = os.path.join(self.data_dir, 'data', 'cities.csv')
            with open(cities_path, 'r', encoding='UTF-8') as f:
                reader = csv.reader(f)
                for row in reader:
                    if len(row) >= 3 and row[0].lower() == city_name.lower():
                        return float(row[1]), float(row[2])
        except FileNotFoundError:
            pass
        
        # Try from 7-day predictions
        predictions = self.load_7day_predictions()
        if predictions:
            for record in predictions:
                if record['City'].lower() == city_name.lower():
                    return float(record['Latitude']), float(record['Longitude'])
        
        return None, None
    
    def get_city_forecast(self, city_name):
        """Get 7-day forecast for a specific city"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        city_forecast = [
            record for record in predictions 
            if record['City'].lower() == city_name.lower()
        ]
        
        return city_forecast if city_forecast else None
    
    def get_date_forecast(self, target_date):
        """Get all city forecasts for a specific date"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        date_forecast = [
            record for record in predictions 
            if record['Date'] == target_date
        ]
        
        return date_forecast if date_forecast else None
    
    def get_high_risk_cities(self, date=None):
        """Get cities with high flood risk (optionally for specific date)"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return []
        
        if date:
            predictions = [
                record for record in predictions 
                if record['Date'] == date
            ]
        
        high_risk_cities = [
            record for record in predictions 
            if record['Predicted_Flood_Risk'] == 1
        ]
        
        return high_risk_cities
    
    def get_summary_stats(self):
        """Get overall summary statistics"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        df = pd.DataFrame(predictions)
        
        total_predictions = len(df)
        high_risk_predictions = len(df[df['Predicted_Flood_Risk'] == 1])
        unique_cities = df['City'].nunique()
        unique_dates = df['Date'].nunique()
        avg_probability = df['Flood_Probability'].mean()
        
        return {
            'total_predictions': total_predictions,
            'high_risk_predictions': high_risk_predictions,
            'high_risk_percentage': round((high_risk_predictions / total_predictions) * 100, 1),
            'unique_cities': unique_cities,
            'forecast_days': unique_dates,
            'average_flood_probability': round(avg_probability, 3),
            'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

def to_serializable(obj):
    """Convert numpy/pandas datatypes into native Python types"""
    if isinstance(obj, (np.integer,)):
        return int(obj)
    elif isinstance(obj, (np.floating,)):
        return float(obj)
    elif isinstance(obj, (np.bool_,)):
        return bool(obj)
    elif isinstance(obj, (np.ndarray, list, tuple)):
        return [to_serializable(x) for x in obj]
    elif isinstance(obj, dict):
        return {k: to_serializable(v) for k, v in obj.items()}
    elif pd.isna(obj):
        return None
    return obj