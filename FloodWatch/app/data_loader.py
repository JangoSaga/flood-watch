import pandas as pd
import csv
import os
from datetime import datetime
import numpy as np

class DataLoader:
    """Centralized data loader for all CSV files generated by enhanced forecast/plotting"""
    
    def __init__(self, base_dir):
        self.base_dir = base_dir
        # Resolve project root as the parent of the app directory
        self.project_root = os.path.abspath(os.path.join(base_dir, '..'))
        # Read data from the root-level data/ directory
        self.data_dir = os.path.join(self.project_root, 'data')
        
    def check_data_availability(self):
        """Check which CSV files are available"""
        files_to_check = {
            '7day_flood_predictions.csv': '7-day forecast predictions',
            'final_plot.csv': 'Main plotting data',
            'risk_zones.csv': 'Risk zones with alert levels',
            'daily_summary.csv': 'Daily forecast statistics',
            'city_summary.csv': 'City-wise risk analysis',
            'cities.csv': 'City coordinates reference'
        }
        
        status = {}
        for filename, description in files_to_check.items():
            file_path = os.path.join(self.data_dir, filename)
            status[f"{filename} ({description})"] = os.path.exists(file_path)
        
        return status
    
    def load_7day_predictions(self):
        """Load 7-day flood predictions"""
        try:
            file_path = os.path.join(self.data_dir, '7day_flood_predictions.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading 7-day predictions: {e}")
            return None
    
    def load_daily_summary(self):
        """Load daily summary data"""
        try:
            file_path = os.path.join(self.data_dir, 'daily_summary.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            # Reset index to get Date as a column if it's in the index
            if 'Date' not in df.columns and df.index.name == 'Date':
                df = df.reset_index()
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading daily summary: {e}")
            return None
    
    def load_city_summary(self):
        """Load city summary data"""
        try:
            file_path = os.path.join(self.data_dir, 'city_summary.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            # Reset index to get City as a column if it's in the index
            if 'City' not in df.columns and df.index.name == 'City':
                df = df.reset_index()
            
            # Handle the Risk_Category column properly
            if 'Overall_Risk_Category' in df.columns:
                df['Risk_Category'] = df['Overall_Risk_Category']
            elif 'Risk_Category' not in df.columns:
                # Create Risk_Category based on Avg_Flood_Probability if it doesn't exist
                df['Risk_Category'] = df['Avg_Flood_Probability'].apply(
                    lambda x: 'Critical' if x >= 0.8 else 
                             'High' if x >= 0.6 else 
                             'Medium' if x >= 0.4 else 'Low'
                )
            
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading city summary: {e}")
            return None
    
    def load_risk_zones(self):
        """Load risk zones data"""
        try:
            file_path = os.path.join(self.data_dir, 'risk_zones.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading risk zones: {e}")
            return None
    
    def load_plotting_data(self):
        """Load final plotting data"""
        try:
            file_path = os.path.join(self.data_dir, 'final_plot.csv')
            if not os.path.exists(file_path):
                return None
            
            df = pd.read_csv(file_path)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error loading plotting data: {e}")
            return None
    
    def get_city_list(self):
        """Get list of all cities from available data"""
        cities = set()
        
        # Try to get from 7-day predictions first
        predictions = self.load_7day_predictions()
        if predictions:
            cities.update([record['City'] for record in predictions])
            return sorted(list(cities))
        
        # Fallback to cities.csv
        try:
            cities_path = os.path.join(self.data_dir, 'cities.csv')
            with open(cities_path, 'r', encoding='UTF-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    if 'city' in row:
                        cities.add(row['city'])
        except FileNotFoundError:
            pass
        
        return sorted(list(cities))
    
    def get_city_coordinates(self, city_name):
        """Get coordinates for a specific city"""
        # Try from cities.csv first
        try:
            cities_path = os.path.join(self.data_dir, 'cities.csv')
            with open(cities_path, 'r', encoding='UTF-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    if row.get('city', '').lower() == city_name.lower():
                        return float(row['latitude']), float(row['longitude'])
        except (FileNotFoundError, KeyError, ValueError):
            pass
        
        # Try from 7-day predictions
        predictions = self.load_7day_predictions()
        if predictions:
            for record in predictions:
                if record['City'].lower() == city_name.lower():
                    return float(record['Latitude']), float(record['Longitude'])
        
        return None, None
    
    def get_city_forecast(self, city_name):
        """Get 7-day forecast for a specific city"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        city_forecast = [
            record for record in predictions 
            if record['City'].lower() == city_name.lower()
        ]
        
        return city_forecast if city_forecast else None
    
    def get_date_forecast(self, target_date):
        """Get all city forecasts for a specific date"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        date_forecast = [
            record for record in predictions 
            if record['Date'] == target_date
        ]
        
        return date_forecast if date_forecast else None
    
    def get_high_risk_cities(self, date=None):
        """Get cities with high flood risk (optionally for specific date)"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return []
        
        if date:
            predictions = [
                record for record in predictions 
                if record['Date'] == date
            ]
        
        high_risk_cities = [
            record for record in predictions 
            if record['Predicted_Flood_Risk'] == 1
        ]
        
        return high_risk_cities
    
    def get_summary_stats(self):
        """Get overall summary statistics"""
        predictions = self.load_7day_predictions()
        if not predictions:
            return None
        
        df = pd.DataFrame(predictions)
        
        total_predictions = len(df)
        high_risk_predictions = len(df[df['Predicted_Flood_Risk'] == 1])
        unique_cities = df['City'].nunique()
        unique_dates = df['Date'].nunique()
        avg_probability = df['Flood_Probability'].mean()
        
        # Risk category distribution if available
        risk_categories = {}
        if 'Risk_Category' in df.columns:
            risk_categories = df['Risk_Category'].value_counts().to_dict()
        
        return {
            'total_predictions': total_predictions,
            'high_risk_predictions': high_risk_predictions,
            'high_risk_percentage': round((high_risk_predictions / total_predictions) * 100, 1),
            'unique_cities': unique_cities,
            'forecast_days': unique_dates,
            'average_flood_probability': round(avg_probability, 3),
            'risk_category_distribution': risk_categories,
            'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

def to_serializable(obj):
    """Convert numpy/pandas datatypes into native Python types"""
    if isinstance(obj, (np.integer,)):
        return int(obj)
    elif isinstance(obj, (np.floating,)):
        return float(obj)
    elif isinstance(obj, (np.bool_,)):
        return bool(obj)
    elif isinstance(obj, (np.ndarray, list, tuple)):
        return [to_serializable(x) for x in obj]
    elif isinstance(obj, dict):
        return {k: to_serializable(v) for k, v in obj.items()}
    elif pd.isna(obj):
        return None
    return obj